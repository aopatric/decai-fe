<!-- JS Client, can connect to signaling server and pingpong w/ python client-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Decentralized Learning Node</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 20px;
            line-height: 1.6;
        }
        .status-container {
            border: 1px solid #ccc;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .status-item {
            margin: 5px 0;
        }
        .status-label {
            font-weight: bold;
        }
        pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 3px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>Decentralized Learning Node</h1>
    <div class="status-container">
        <div class="status-item">
            <span class="status-label">Status:</span>
            <span id="status">Connecting to signaling server...</span>
        </div>
        <div class="status-item">
            <span class="status-label">Node Rank:</span>
            <span id="rank">-</span>
        </div>
        <div class="status-item">
            <span class="status-label">Neighbors:</span>
            <span id="neighbors">None</span>
        </div>
        <div class="status-item">
            <span class="status-label">Active Connections:</span>
            <span id="connections">None</span>
        </div>
    </div>

    <script>
      class WebRTCNode {
          constructor(signalingServer) {
              this.signalingServer = signalingServer;
              this.ws = null;
              this.connections = new Map();
              this.dataChannels = new Map();
              this.rank = null;
              this.neighbors = null;
              this.pendingConnections = new Set();
              
              this.connect();
          }

          async connect() {
              this.ws = new WebSocket(this.signalingServer);
              
              this.ws.onopen = () => {
                  console.log('Connected to signaling server');
                  this.ws.send(JSON.stringify({
                      type: 'ready',
                      clientType: 'javascript'
                  }));
                  document.getElementById('status').textContent = 'Connected to signaling server';
              };

              this.ws.onmessage = (event) => {
                  const message = JSON.parse(event.data);
                  this.handleSignalingMessage(message);
              };

              this.ws.onclose = () => {
                  console.log('Disconnected from signaling server');
                  document.getElementById('status').textContent = 'Disconnected from signaling server';
              };

              this.ws.onerror = (error) => {
                  console.error('WebSocket error:', error);
                  document.getElementById('status').textContent = 'Error connecting to server';
              };
          }

          async handleSignalingMessage(message) {
              console.log('Received message:', message.type);
              
              switch (message.type) {
                  case 'topology':
                      await this.handleTopology(message);
                      break;
                  case 'signal':
                      await this.handlePeerSignaling(message);
                      break;
                  case 'network_ready':
                      document.getElementById('status').textContent = 'Network Ready';
                      break;
              }
          }

          async handleTopology(message) {
              this.rank = message.rank;
              this.neighbors = message.neighbors;
              
              console.log(`Received topology. Rank: ${this.rank}, Neighbors:`, this.neighbors);
              this.updateConnectionsDisplay();

              // Initiate connections to higher-ranked neighbors
              for (const [direction, neighborRank] of Object.entries(this.neighbors)) {
                  if (neighborRank > this.rank && !this.connections.has(neighborRank)) {
                      console.log(`Initiating connection to higher-ranked neighbor ${neighborRank}`);
                      await this.initiateConnection(neighborRank);
                  }
              }

              // Start debug loop after receiving topology
              this.startDebugLoop();
          }

          async createPeerConnection(targetRank) {
              const config = {
                  iceServers: [
                      { urls: 'stun:stun.l.google.com:19302' },
                      { urls: 'stun:stun1.l.google.com:19302' }
                  ],
                  iceTransportPolicy: 'all',
                  iceCandidatePoolSize: 10
              };
              
              const pc = new RTCPeerConnection(config);
              this.connections.set(targetRank, pc);

              pc.oniceconnectionstatechange = () => {
                  console.log(`ICE connection state with ${targetRank}:`, pc.iceConnectionState);
                  this.debugConnectionState(targetRank);
                  this.updateConnectionsDisplay();
              };

              pc.onconnectionstatechange = () => {
                  console.log(`Connection state with ${targetRank}:`, pc.connectionState);
                  this.debugConnectionState(targetRank);
                  this.updateConnectionsDisplay();
              };

              pc.onicegatheringstatechange = () => {
                  console.log(`ICE gathering state with ${targetRank}:`, pc.iceGatheringState);
                  this.debugConnectionState(targetRank);
              };

              pc.onsignalingstatechange = () => {
                  console.log(`Signaling state with ${targetRank}:`, pc.signalingState);
                  this.debugConnectionState(targetRank);
              };

              pc.onicecandidate = (event) => {
                  if (event.candidate) {
                      this.sendSignaling(targetRank, {
                          type: 'candidate',
                          candidate: {
                              sdpMid: event.candidate.sdpMid,
                              sdpMLineIndex: event.candidate.sdpMLineIndex,
                              candidate: event.candidate.candidate
                          }
                      });
                  }
              };

              pc.ondatachannel = (event) => {
                  console.log(`Received data channel from ${targetRank}`);
                  this.setupDataChannel(event.channel, targetRank);
              };

              return pc;
          }

          async initiateConnection(targetRank) {
              try {
                  const pc = await this.createPeerConnection(targetRank);
                  
                  // Create data channel
                  const channel = pc.createDataChannel(`channel-${this.rank}-${targetRank}`);
                  this.setupDataChannel(channel, targetRank);
                  
                  // Create and send offer
                  const offer = await pc.createOffer();
                  await pc.setLocalDescription(offer);
                  
                  this.sendSignaling(targetRank, {
                      type: 'offer',
                      sdp: pc.localDescription.sdp
                  });
              } catch (error) {
                  console.error('Error initiating connection:', error);
              }
          }

          setupDataChannel(channel, peerRank) {
              this.dataChannels.set(peerRank, channel);

              channel.onopen = () => {
                  console.log(`Data channel opened with ${peerRank}`);
                  this.updateConnectionsDisplay();
                  this.notifyConnectionEstablished(peerRank);
                  this.startPingPong(peerRank);
              };

              channel.onclose = () => {
                  console.log(`Data channel closed with ${peerRank}`);
                  this.dataChannels.delete(peerRank);
                  this.updateConnectionsDisplay();
              };

              channel.onerror = (error) => {
                  console.error(`Data channel error with ${peerRank}:`, error);
              };

              channel.onmessage = (event) => {
                  try {
                      const message = JSON.parse(event.data);
                      if (message.type === 'ping') {
                          channel.send(JSON.stringify({
                              type: 'pong',
                              timestamp: message.timestamp,
                              respondedAt: Date.now()
                          }));
                      } else if (message.type === 'pong') {
                          const rtt = Date.now() - message.timestamp;
                          console.log(`RTT to ${peerRank}: ${rtt}ms`);
                      }
                  } catch (error) {
                      console.error('Error processing message:', error);
                  }
              };
          }

          startPingPong(peerRank) {
              setInterval(() => {
                  const channel = this.dataChannels.get(peerRank);
                  if (channel && channel.readyState === 'open') {
                      channel.send(JSON.stringify({
                          type: 'ping',
                          timestamp: Date.now()
                      }));
                  }
              }, 5000);
          }

          async handlePeerSignaling(message) {
              const senderRank = message.senderRank;
              const data = message.data;
              
              if (!this.connections.has(senderRank)) {
                  await this.createPeerConnection(senderRank);
              }
              
              const pc = this.connections.get(senderRank);

              try {
                  switch (data.type) {
                      case 'offer':
                          console.log(`Received offer from ${senderRank}`);
                          await pc.setRemoteDescription(new RTCSessionDescription({
                              type: 'offer',
                              sdp: data.sdp
                          }));
                          
                          const answer = await pc.createAnswer();
                          await pc.setLocalDescription(answer);
                          
                          this.sendSignaling(senderRank, {
                              type: 'answer',
                              sdp: answer.sdp
                          });
                          break;
                          
                      case 'answer':
                          console.log(`Received answer from ${senderRank}`);
                          await pc.setRemoteDescription(new RTCSessionDescription({
                              type: 'answer',
                              sdp: data.sdp
                          }));
                          break;
                          
                      case 'candidate':
                          console.log(`Received ICE candidate from ${senderRank}`);
                          if (pc.remoteDescription) {
                              try {
                                  await pc.addIceCandidate(new RTCIceCandidate({
                                      sdpMid: data.candidate.sdpMid,
                                      sdpMLineIndex: data.candidate.sdpMLineIndex,
                                      candidate: data.candidate.candidate
                                  }));
                              } catch (e) {
                                  console.error('Error adding ICE candidate:', e);
                              }
                          }
                          break;
                  }
              } catch (error) {
                  console.error('Error handling peer signaling:', error);
                  console.error('Message was:', message);
              }
          }

          sendSignaling(targetRank, data) {
              if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                  this.ws.send(JSON.stringify({
                      type: 'signal',
                      targetRank: targetRank,
                      data: data
                  }));
              }
          }

          notifyConnectionEstablished(peerRank) {
              if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                  this.ws.send(JSON.stringify({
                      type: 'connection_established',
                      peerRank: peerRank
                  }));
              }
          }

          debugConnectionState(peerRank) {
              const pc = this.connections.get(peerRank);
              if (pc) {
                  console.log(`Debug connection state with ${peerRank}:`, {
                      connectionState: pc.connectionState,
                      iceConnectionState: pc.iceConnectionState,
                      iceGatheringState: pc.iceGatheringState,
                      signalingState: pc.signalingState,
                      dataChannelState: this.dataChannels.get(peerRank)?.readyState || 'no channel'
                  });
              }
          }

          startDebugLoop() {
              setInterval(() => {
                  console.log('\n--- Debug Status Update ---');
                  console.log('My rank:', this.rank);
                  console.log('My neighbors:', this.neighbors);
                  console.log('Pending connections:', Array.from(this.pendingConnections));
                  
                  if (this.neighbors) {
                      Object.values(this.neighbors).forEach(neighborRank => {
                          this.debugConnectionState(neighborRank);
                      });
                  }

                  console.log('Active data channels:', Array.from(this.dataChannels.entries())
                      .map(([rank, channel]) => `${rank}: ${channel.readyState}`)
                      .join(', ') || 'None');
                  console.log('------------------------\n');
              }, 5000);
          }

          updateConnectionsDisplay() {
              const activeConnections = Array.from(this.dataChannels.entries())
                  .filter(([_, channel]) => channel.readyState === 'open')
                  .map(([rank, _]) => rank);
              
              const connectionsStr = activeConnections.length > 0 ? 
                  activeConnections.join(', ') : 'None';
              
              document.getElementById('connections').textContent = 
                  `Active Connections: ${connectionsStr}`;

              // Update other status displays
              document.getElementById('rank').textContent = `Rank: ${this.rank || '-'}`;
              document.getElementById('neighbors').textContent = 
                  `Neighbors: ${this.neighbors ? JSON.stringify(this.neighbors) : 'None'}`;
          }
      }
        const node = new WebRTCNode('ws://localhost:8080');
    </script>
</body>
</html>